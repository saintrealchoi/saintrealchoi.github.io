<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Java]Day02 - 자바 데이터타입,변수 그리고 배열</title>
      <link href="2021/01/20/java-day2/"/>
      <url>2021/01/20/java-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="Review-Day01"><a href="#Review-Day01" class="headerlink" title="Review Day01"></a>Review Day01</h2><p>오늘 포스트에 앞서 지난 시간에 다뤘던 Compile에 대해서 다시 한 번 다뤄보겠다.</p><blockquote><p>Q1. java14로 compile한 파일을 java8로 실행하면 어떻게 될 것인가?<br>Q2. java8로 compile한 파일을 java14로 실행하면 어떻게 될 것인가?</p></blockquote><p>Q1의 정답은 <code>Error</code>, Q2의 정답은 <code>Success</code>이다. 쉽게 생각하면 낮은 버젼의 컴파일러로 컴파일 시 높은 버젼의 자바로 실행은 가능하지만 높은 버젼의 컴파일러로 컴파일 시 낮은 버젼의 자바로 실행은 불가능하다.</p><blockquote><p>Q3. 그렇다면 java14버젼으로 compile시에는 java8로는 절대 실행불가능한 것인가?</p></blockquote><p>Q3의 정답은 <code>False</code>이다. <code>javac -source 1.6 -target 1.6</code>옵션을 줌으로써 컴파일시 실행도 가능해진다. 높은 버젼에서만 사용할 수 있는 기능도 컴파일러가 낮은버젼에 호환되도록 컴파일을 하기 때문에 실행이 가능하지는것이다. (모든 기능이 가능한 것은 아니니까 굳이 그러진말자!)<br>그러나 정말 안타깝게도, 일부 Maven plugin이 간혹 특정버젼으로 만들어지고 낮은버젼으로 호환이 안되어 프로젝트 시 확인을 해야한다.</p><p>높은 버젼의 컴파일시 낮은 버젼으로 실행하면 다음과 같은 에러가 뜬다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InsupportedClassVersionError: 파일명 has been compiled by a more recent version of the Java Runtime (class file version 58.0), this version of the Java Runtime only recognizes class file versions up to 52.0</span><br></pre></td></tr></table></figure><p>이는 위에 설명했던 그대로의 말을 의미한다.</p><blockquote><p>Q4. javac는 어디에 들어있는가?</p></blockquote><p>Q4의 정답은 <code>JDK</code>이다. <code>compile</code>을 하는 것은 개발자의 몫이기 때문에 JDK에만 들어가있다. JAVA9부터는 JRE는 따로 배포 안하므로 나중에 확인해보자.</p><blockquote><p>Q5. 바이트코드는 왜 바이트코드에요?</p></blockquote><p>Q5의 정답은 <code>opcode가 1바이트이기 때문</code>이다. 시스템프로그래밍 수업을 들었다면 알겠지만 기계어로 바꾸는 과정 중에 바이트코드나 어셈블리어같은 것들은 opcode라는 것이 존재한다. 이것이 1바이트이기 때문에 바이트코드라고 한다. 또한, <strong>java뿐만 아니라 다른 언어</strong>들도 적절한 컴파일러로 통해 바이트코드로 변환이 된다면 jvm은 이를 실행할 수 있다.</p><hr><h2 id="Day02-자바-데이터-타입-변수-그리고-배열"><a href="#Day02-자바-데이터-타입-변수-그리고-배열" class="headerlink" title="Day02. 자바 데이터 타입, 변수 그리고 배열"></a>Day02. 자바 데이터 타입, 변수 그리고 배열</h2><hr><h3 id="프리미티브-타입-종류와-값의-범위-그리고-기본-값"><a href="#프리미티브-타입-종류와-값의-범위-그리고-기본-값" class="headerlink" title="프리미티브 타입 종류와 값의 범위 그리고 기본 값"></a>프리미티브 타입 종류와 값의 범위 그리고 기본 값</h3><p>변수의 타입에는 크게 두가지로 나눌 수 있다.</p><ol><li>Primitive Type</li><li>Reference Type</li></ol><p>이중 Primitive Type에는 총 8개의 타입이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.<br>문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며, <strong>정수형 또는 실수형과 연산도 가능하다.</strong> 반면에 boolean은 다른 기본형과의 연산이 불가능하다. 즉, boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다. 정수는 가장 ㅁ많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르므로 저장할 값의 범위에 맞는 타입을 선택하면 되지만, 일반적으로 int를 많이 사용한다. 왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다. 효율적인 실행보다 메모리를 절약하려면, byte나 short를 선택하자.</p><p>Reference Type은 다음과 같다.</p><blockquote><p>“The basic difference is that primitive variables store the actual values, whereas reference variables store the addresses of the objects they refer to.”    <a href="https://stackoverflow.com/a/32049775">출처</a></p></blockquote><h3 id="상수와-리터럴"><a href="#상수와-리터럴" class="headerlink" title="상수와 리터럴"></a>상수와 리터럴</h3><p>‘상수(constant)’는 변수와 마찬가지로 ‘값을 저장할 수 있는 공간’이다. 하지만 말그대로 변수는 변할 수 있는 공간이지만 상수는 변할 수 없는 공간이다. 상수의 이름은 모두 <strong>대문자</strong>로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져있는경우 ‘_’로 구분한다. (ex. <code>final int MAX_SPEED</code>)<br>‘리터럴(literal)’은 상수와 구분짓기 위해 만든 것으로 그 자체로 값을 의미한다.</p><blockquote><p>“A literal is the source code representation of a fixed value; literals are represented directly in your code without requiring computation. As shown below, it’s possible to assign a literal to a variable of a primitive type”   <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">출처</a></p></blockquote><h3 id="변수의-스코프와-라이프타임"><a href="#변수의-스코프와-라이프타임" class="headerlink" title="변수의 스코프와 라이프타임"></a>변수의 스코프와 라이프타임</h3><p>변수의 스코프란 말그대로 스코프이다. 즉, 변수가 살아있는 범위에 대해 말하는 것이다. 라이프타임과 스코프는 붙어다니는 단어들이다.<br>이제 우리는 변수를 instance, static, local로 나눌 수 있는데 이는 다음과 같이 쓸 수 있다. <a href="https://www.tutorialspoint.com/scope-and-lifetime-of-variables-in-java">출처</a></p><ol><li><p>Instance Variable<br>Scope : throughout the class except in static methods<br>Lifetime : until the object stays in memory.</p></li><li><p>Static(Class) Variable<br>Scope : throughout the class<br>Lifetime : until the end of the program or as long as the class is loaded in memory.</p></li><li><p>Local Variable<br>Scope : within the block in which it is declared<br>Lifetime : until the control leaves the block in which it is declared.</p></li></ol><h3 id="타입-변환-캐스팅-그리고-타입-프로모션"><a href="#타입-변환-캐스팅-그리고-타입-프로모션" class="headerlink" title="타입 변환, 캐스팅 그리고 타입 프로모션"></a>타입 변환, 캐스팅 그리고 타입 프로모션</h3><p>타입 변환이란 말 그대로 타입 변환이다.(Dejavu..) byte로 선언했던 변수를 int 또는 기타 type으로 변환시키는 것이다. 하지만 이는 굉장히 중요한 문제이다. C를 처음 접했었다면 처음에 부딪혔던 난관이 있을것이다. 0.5를 표현하는 것이다. int형 변수 a,b를 각각 1, 2로 했다면 우리는 0.5는 당연히 a/b일 것이라 생각했겠지만 절대 0.5가 출력되지 않는다. 이는 변수의 자료형이 int로 반환되기 때문에 절대 원하는 값인 0.5가 아닌 0이 출력이 되었던걸 경험했을 것이다. 그래서 필요한 것이 이런 타입변환이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double c &#x3D; (double)(a&#x2F;b);</span><br></pre></td></tr></table></figure><p>이런식으로 하는 것이 캐스팅이다. 굉장히 간단하지 않은가? 원하는 타입으로 앞에 괄호를 붙여쓰기만 하면되는 것이다.<br>하지만 세상은 그렇게 녹록치 않다. boolean을 제외한 Primitive Type간에는 자유롭게 변환이 가능하지만(물론 데이터 손실은 있을 수 있다.)  Primitive Type간에도 형변환을 하는것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략이 가능하다. Reference Type간에는 implicit up-casting, explicit down-casting이 이루어진다.</p><h3 id="1차-및-2차-배열-선언하기"><a href="#1차-및-2차-배열-선언하기" class="headerlink" title="1차 및 2차 배열 선언하기"></a>1차 및 2차 배열 선언하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">int[][] b &#x3D; &#123;&#123;2,3,4&#125;,&#123;5,6,7&#125;&#125;;</span><br><span class="line">이부분은 이정도로만 해두고 다음시간에 Review를 통해 더 자세히 다뤄보도록 하겠다.</span><br></pre></td></tr></table></figure><h3 id="타입-추론-var"><a href="#타입-추론-var" class="headerlink" title="타입 추론, var"></a>타입 추론, var</h3><p>코틀린을 써보며 자주 사용했던 <code>var</code>이다. 그때는 뭔지도 모르고 무조건! <code>var</code>로 선언했었다. 물론 차이가 있겠지만 우선 자바로 배워보도록 하겠다. 우선 <code>var</code>은 java10에서 생겨난 것이다. <code>var</code>로 선언한다면 런타임시 변수의 종류를 파악해 알아서 변환시켜준다.  타입추론이란 자바자체적으로 어떤 타입인지 예측하고, 그것을 사용하는 것을 의미한다.</p><p> <a href="https://johngrib.github.io/wiki/java10-var/">올바른 사용과 잘못된 사용</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;            <span class="comment">// Legal</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>, c = <span class="number">3.0</span>;   <span class="comment">// Illegal: multiple declarators</span></span><br><span class="line"><span class="keyword">var</span> d[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// Illegal: extra bracket pairs</span></span><br><span class="line"><span class="keyword">var</span> e;                <span class="comment">// Illegal: no initializer</span></span><br><span class="line"><span class="keyword">var</span> f = &#123; <span class="number">6</span> &#125;;        <span class="comment">// Illegal: array initializer</span></span><br><span class="line"><span class="keyword">var</span> g = (g = <span class="number">7</span>);      <span class="comment">// Illegal: self reference in initializer</span></span><br></pre></td></tr></table></figure><p> <a href="https://johngrib.github.io/wiki/java10-var/">타입</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;                <span class="comment">// a has type &#x27;int&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = java.util.List.of(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// b has type &#x27;List&lt;Integer&gt;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;x&quot;</span>.getClass();</span><br><span class="line">                          <span class="comment">// (see JLS 15.12.2.6)</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Object() &#123;&#125;;  <span class="comment">// d has the type of the anonymous class</span></span><br><span class="line"><span class="keyword">var</span> e = (CharSequence &amp; Comparable&lt;String&gt;) <span class="string">&quot;x&quot;</span>;</span><br><span class="line">                          <span class="comment">// e has type CharSequence &amp; Comparable&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> f = () -&gt; <span class="string">&quot;hello&quot;</span>;    <span class="comment">// Illegal: lambda not in an assignment context</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">null</span>;             <span class="comment">// Illegal: null type</span></span><br></pre></td></tr></table></figure><p>엄청 편해보여서 모든 변수를 var로 선언해버리는 것이 어떻겠냐는 생각을 할 수 있겠지만 아쉽게도 그러면 안된다. 예상치못한 에러에 대처할 수 없어진다. 그렇다면 언제 사용하는 것이냐?에 대해서는 <a href="https://velog.io/@composite/Java-10-%EC%97%90%EC%84%9C-var-%EC%9E%AC%EB%8C%80%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">다음의 글</a>을 살펴보는 것이 좋겠다. <code>제네릭</code>,<code>람다</code>,<code>foreach</code>구문 등 쓰는 부분이 굉장히 많다. 이는 추후에 더 자세히 다뤄보도록 하겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> java10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AAIS]Intro.</title>
      <link href="2021/01/19/aais-00/"/>
      <url>2021/01/19/aais-00/</url>
      
        <content type="html"><![CDATA[<h1 id="In-AAIS-Advanced-Application-for-Intelligence-Systems-Lab-at-Hanyang-University"><a href="#In-AAIS-Advanced-Application-for-Intelligence-Systems-Lab-at-Hanyang-University" class="headerlink" title="In AAIS(Advanced Application for Intelligence Systems) Lab at Hanyang University"></a>In AAIS(Advanced Application for Intelligence Systems) Lab at Hanyang University</h1><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>이번 겨울방학에 무엇을 해야할 지 굉장히 생각이 많았다. 자바백엔드개발자로써 시작을 위해 자바8,스프링부트를 시작했고 이제 코딩테스트도 준비해야한다 생각해서 <code>Programmers</code>와 <code>Leetcode</code>의 코딩테스트 연습문제를 풀고 있다. 또한, 도커를 공부할 것이다.<br>아직 끝나지 않았다. 봉사활동도 하지않아서 봉사활동(온라인..)도 신청했고 계절학기도 신청해서 오늘자(210119)로 마무리 됐다. (선형대수 만세)<br>이렇게 할게 많은 와중에 노영균교수님께서 AAIS LAB 인턴을 모집하셔서 바로 신청을 했다.<br>비록 늦게 신청을 했지만 교수님께서 받아주셔서 인턴으로써 활동을 하게 되었다.</p><blockquote><p>이번방학 할 목록</p></blockquote><ol><li>AAIS LAB 인턴</li><li>JAVA8</li><li>스프링부트</li><li>도커</li><li>코딩테스트준비</li><li>봉사활동</li><li><del>계절학기</del></li></ol><p>일단 목표는 크게 잡고 하나씩 쳐낼(?) 것이다. 아직까지는 만족스러운 방학생활이다.</p><p>근황은 이쯤에서 마무리하고, 랩실에서 할 내용에 대해 간략히 정리해보겠다.</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>내가 다룰 주제는 <a href="https://www.nature.com/articles/s41598-020-80182-8">Age-gruop determination of living individuals using first molar images based on artificial intelligence</a>이다.<br>교수님께서 가장 쉽게 구현할 수 있다고 강조해주신 자료이다. 아직 텐서플로우는 커녕 이론도 잘 모르는 상태라 가장 끌렸다. 이것은 두번째 이유이고 첫번째로는 <strong>재미</strong>있어보였다. 추리장르를 좋아하는 사람으로써 치아의 나이를 추론한다는 내용은 굉장히 흥미로웠기 때문이다.</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>Dental age estimation of living individuals is difcult and challenging, and there is no consensus method in adults with permanent dentition. Thus, we aimed to provide an accurate and robust artifcial intelligence (AI)-based diagnostic system for age-group estimation by incorporating a convolutional neural network (CNN) using dental X-ray image patches of the frst molars extracted via panoramic radiography. The data set consisted of four frst molar images from the right and left sides of the maxilla and mandible of each of 1586 individuals across all age groups, which were extracted from their panoramic radiographs. The accuracy of the tooth-wise estimation was 89.05 to 90.27%. Performance accuracy was evaluated mainly using a majority voting system and area under curve (AUC) scores. The AUC scores ranged from 0.94 to 0.98 for all age groups, which indicates outstanding capacity. The learned features of CNNs were visualized as a heatmap, and revealed that CNNs focus on diferentiated anatomical parameters, including tooth pulp, alveolar bone level, or interdental space, depending on the age and location of the tooth. With this, we provided a deeper understanding of the most informative regions distinguished by age groups. The prediction accuracy and heat map analyses support that this AI-based age-group determination model is plausible and useful.</p></blockquote><p>내가 정말 정말 간단하게 요약하자면 1586명의 첫번째 어금니 4개를 데이터를 통해 나이구간을 추정한다는 것이다. 특정한 나이를 구하는 것이 아니라 나이구간을 구한다. CNN을 통해 학습시키며 잇속(tooth pulp), 이틀뼈(alveolar bone level), 또는 수특부(interdental space)를 <strong>나이와 치아의 위치</strong>에 따라 파라미터로 받는다.<br>여기서 중요하게 봐야할 것은 convolutional neural network(CNN)과 파라미터를 다르게 받는다는 점이다. 모든 이를 같은 특징을 통해 구별하는 것이 아니라 나이대, 치아의 위치에 따라서 다르게 구별한다는 것이다. 이는 나중에 다루고(잘 모른다..) 이번 포스트에서는 CNN으로 간단하게 시작해보겠다.</p><h2 id="CNN-Convolutional-Neural-Network"><a href="#CNN-Convolutional-Neural-Network" class="headerlink" title="CNN(Convolutional Neural Network)"></a>CNN(Convolutional Neural Network)</h2><p align="center"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnIswa%2FbtqFrmYm9zI%2FcF0xZms06Zkdjy95Bt0K8k%2Fimg.gif"></p><p>위 그림과 같이 일반적으로 CNN모델은 3 * 3 필터를 주로 사용한다. 위 그림에서는 3개의 channel에서 3개의 convolutional filter를 사용하여 곱을하고 그 결과를 모두 합하는 것이다.<br>위에서의 곱이란 Convolution Product(합성곱)을 말한다. 그 수학적 공식은 다음과 같다.</p><p align="center"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd6EbAa%2FbtqFpBf5GwW%2Fb2ne6NbSP2mbQA9hT0NvpK%2Fimg.jpg"></p><br><p>수학적인 얘기는 아직 잘 모를뿐더러 나는 이론적인 얘기보단 용도와 결과에 대해서만 우선! 다룰 것이다.</p><p align="center"><img src="https://blogfiles.pstatic.net/20160105_9/laonple_14519535933045r2XJ_JPEG/%C0%CC%B9%CC%C1%F6_207.jpg?type=w2" height = "300px" width = "600px"></p><p align="center"><img src="https://blogfiles.pstatic.net/20160105_103/laonple_1451953593820FopUd_JPEG/%C0%CC%B9%CC%C1%F6_208.jpg?type=w2" height = "300px" width = "600px"></p><p>CNN을 사용하는 이유는 위의 그림에서의 이유가 가장 크다. 같은 A라는 문자를 입력한다 해도 한 픽셀만 translation되어도 다른 이미지로 인식을 하기 때문에 문제가 된다. data가 굉장히 많아 많은 양을 학습시켰다고 하더라도 약간이라도 translation된다면 전혀 모르는 데이터가 되기 때문이다. 따라서 이를 사용하게 된다.</p><p>앞선 움짤(.gif)을 봤듯이 필터를 이용하여 얻은 output을 Maxpooling Layer을 통과시켜 이미지의 특징점을 잡을 수 있다고 한다.</p><p>여기서 Pooling Layer란 차례로 처리되는 데이터의 크기를 줄이는 것을 말한다. 이 과정으로 모델의 전체 파라미터의 수를 크게 줄일 수 있다.<br>풀링에는 MaxPooling과 AveragePooling이 존재하는데, MaxPooling은 해당 영역에서 최댓값을 찾는 방법이고, AveragePooling은 해당 영역의 평균값을 계산하는 방법이다.<br>이러한 과정을 거치는 이유에 대해서 잠깐 말하자면 더 높은 정확도를 위해서는 필터가 많아야 하는데, 필터가 늘어날 수록 Feature Map이 늘어난다.이는 딥러닝 모델의 Dimension이 늘어난다는 것이고, High Dimension 모델은 그만큼 파라미터의 수 또한 늘어난는 것이다.이는 Over fitting의 문제점 뿐만이 아니라, 모델의 사이즈와 레이턴시에도 큰 영향을 끼친다. 따라서 차원을 감소시킬 필요성이 있는데,이것을 하는 방법이 Pooling Layer를 활용하는 것이다. 오버피팅에 대해서는 다음에 또 batchnormalization을 다루며 할것이다.</p><p>우선 간단하게 정리한 내용은 위와 같다. 아직 모르는 내용도 많고 겉핥기식 공부라 많이 부족한 글이다. 나중에 이 글을 봤을 때 조금이나마 노력했다라는 생각이 들었다면 오늘의 나는 만족할 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> AAIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> AAIS </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java]Day01 - JVM이란?</title>
      <link href="2021/01/19/java-day1/"/>
      <url>2021/01/19/java-day1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM이란"><a href="#1-JVM이란" class="headerlink" title="1. JVM이란?"></a>1. JVM이란?</h2><h3 id="JVM의-용도와-정의"><a href="#JVM의-용도와-정의" class="headerlink" title="JVM의 용도와 정의"></a>JVM의 용도와 정의</h3><hr><p>JVM에는 2가지 기본 기능이 있다.<br> 첫번째로 자바 프로그램이 어느 기기, 또는 어느 운영체제 상에서도 실행될 수 있게 하는 것과 프로그램 메모리를 관리하고 최적화하는 것이다. 이에 대해서는 JVM 구성요소에서 자세히 다뤄보겠다.<br> 가장 유명한 원칙인 “한 번 작성해, 어디에서나 실행한다.(Write Once, Run Anywhere, WORA)”가 바로 이것이다. 즉, 자바 애플리케이션은 JVM 위에서 동작하기 때문에 JVM에 종속적이나, OS와 하드웨어와는 독립적이라 프로그램의 변경없이 실행이 가능하다.<br>자바가 나온 시점에는 메모리관리와 OS와 하드웨어 의존성이 있었기 때문에 이는 큰 장점이기도 했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 기술적 정의 : JVM은 코드를 실행하고 해당 코드에 대해 런타임 환경을 제공하는 소프트웨어 프로그램에 대한 사양(Specification)이다.</span><br><span class="line">- 일반적 정의 : JVM은 자바 프로그램을 실행하는 방법이다. JVM의 설정을 구성한 다음 설정사항에 따라 실행 중에 프로그램 리소스를 관리한다.</span><br></pre></td></tr></table></figure><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a><strong>Garbage Collection</strong></h3><p> 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했었다. 자바에서는 JVM이 프로그램 메모리를 관리한다. JVM은 가비지 컬렉션이란 프로세스를 통해 메모리를 관리하며, 이는 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거한다. 즉, 실행중인 JVM내부에서 일어난다.<br> 그럼 왜 많은 개발자들이 C나 C++같이 메모리관리를 직접해야하는 언어를 사용하냐는 생각이 들 수 있다. 하지만 편리함에는 대가를 치루는 법. 앞서 말했듯 JVM이 지속적으로 가비지 컬렉션을 하기 때문에 시간이 그만큼 많이 들어간다. 하지만, 직접관리를 한다면 그 시간을 줄일 수 있을 것이다. 그래서 초창기 자바의 가비지컬렉션에 대해 속도측면에서 많이 까였다. 하지만, 지금은 많은 개발과 최적화를 통해 크게 개선되어 메탈에 가까워졌다.</p><hr><h3 id="컴파일-하는-방법"><a href="#컴파일-하는-방법" class="headerlink" title="컴파일 하는 방법"></a>컴파일 하는 방법</h3><p><a href="https://zerodark.tistory.com/14">컴파일 하는 과정</a><br>위 링크에 컴파일 하는 과정을 잘 요약해주었다.</p><p>컴파일 하는 과정은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 소스코드를 작성한다.(.java)</span><br><span class="line">2. 컴파일러를 통해 바이트코드로 컴파일한다. (.class)</span><br><span class="line">3. java명령어로 프로그램을 실행한다.</span><br></pre></td></tr></table></figure><p>대부분의 나같은 주니어개발자들은 intelliJ나 이클립스같은 IDE를 통해 컴파일부터 실행까지 모두 하지만 위의 과정들은 당연히 알아두어야한다.</p><hr><h3 id="바이트코드란"><a href="#바이트코드란" class="headerlink" title="바이트코드란?"></a>바이트코드란?</h3><p>앞선 과정중에 <code>바이트코드</code>라는 것이나온다. 보통 C나 C++을 배우다보면 이런 것은 들어본 적이 없다. 바이트 코드의 정의는 다음과 같다.</p><blockquote><p>바이트코드(Bytecode, portable code, p-code)는 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다. 하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적이다.<br>다음의 자바코드가 있다고 하자.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 다음과 같은 바이트코드로 번역된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0:   iconst_2</span><br><span class="line">1:   istore_1</span><br><span class="line">2:   iload_1</span><br><span class="line">3:   sipush  1000</span><br><span class="line">6:   if_icmpge       44</span><br><span class="line">9:   iconst_2</span><br><span class="line">10:  istore_2</span><br><span class="line">11:  iload_2</span><br><span class="line">12:  iload_1</span><br><span class="line">13:  if_icmpge       31</span><br><span class="line">16:  iload_1</span><br><span class="line">17:  iload_2</span><br><span class="line">18:  irem</span><br><span class="line">19:  ifne    25</span><br><span class="line">22:  goto    38</span><br><span class="line">25:  iinc    2, 1</span><br><span class="line">28:  goto    11</span><br><span class="line">31:  getstatic       #84; &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">34:  iload_1</span><br><span class="line">35:  invokevirtual   #85; &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">38:  iinc    1, 1</span><br><span class="line">41:  goto    2</span><br><span class="line">44:  return</span><br></pre></td></tr></table></figure><p>바이트코드도 컴파일의 과정이므로 당연히 사람이 읽기 쉽도록 쓰인 소스코드보다 덜 추상적이며, 더 간결하고, 더 컴퓨터 중심적이다.(어셈블리어와 비슷한형태다.) 실은 아까 보여준 컴파일 과정중에 한가지 과정이 생략되었는데, 바로 실행전에 JIT컴파일러로 기계코드로 바꾸는 것이다. 이에 대해서는 다음 과정에서 살펴보겠다.</p><hr><h3 id="JIT-컴파일러란"><a href="#JIT-컴파일러란" class="headerlink" title="JIT 컴파일러란?"></a>JIT 컴파일러란?</h3><p>정의는 다음과 같다.</p><blockquote><p>JIT 컴파일(just-in-time compilation) 또는 동적 번역(dynamic translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다.</p></blockquote><p>이런 기계어 변환은 코드가 실행되는 과정에 실시간으로 일어나며(그래서 Just-In-Time이다), 전체 코드의 필요한 부분만 변환한다. 기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용시 컴파일을 다시 할 필요가 없다.</p><p>일반적인 <code>인터프러터 언어(예시: cpython)</code>는 바이트코드나 소스코드를 최적화 과정이 없기 번역하기 때문에 성능이 낮다. 반면 <code>정적으로 컴파일하는 언어(예시: c 언어)</code>는 실행 전에 무조건 컴파일을 해야하기 때문에 다양한 플랫폼에 맞게 컴파일을 하려면 시간이 오래 걸린다. <code>동적 컴파일 환경</code>은 실행 과정에서 컴파일을 할 수 있기 위해 만들어졌다. JIT는 정적 컴파일러 만큼 빠르면서 인터프러터 언어의 빠른 응답속도를 추구하기 위해 사용한다. 바이트코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해주기 때문에 바이트코드에서 기계어 번역은 훨씬 빠르게 진행될 수 있다. 또한 바이트코드는 이식성이 뛰어나 가상 머신이 설치되어 있으면 빠르게 실행할 수 있다.</p><hr><h3 id="JVM-구성요소"><a href="#JVM-구성요소" class="headerlink" title="JVM 구성요소"></a>JVM 구성요소</h3><p align="center"><img src="https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png"></p><p>JVM에는 3가지 측면이 있다고 할 수 있다. 표준(Specification), 구현(Implementation ) 그리고 인스턴스(Instance)인데, 각각에 대해 살펴보자.</p><h4 id="1-표준-Specification"><a href="#1-표준-Specification" class="headerlink" title="1. 표준(Specification)"></a>1. 표준(Specification)</h4><p>첫째, JVM은 소프트웨어 사양이다. 다소 순환적인 방식으로, JVM 사양은 구현에 있어 최대한의 창조성을 허용하기 위해, JVM 구현 세부사항이 사양 안에 정의되어 있지 않다고 강조하고 있다.<br>결국, JVM이 해야만 하는 일은 자바 프로그램을 정확하게 실행하는 것뿐이다. 간단해 보인다, 심지어 겉으로 보기에는 단순해 보이기도 하지만, 자바 언어의 능력과 유연성을 고려할 때, 이것은 엄청나게 힘든 일이다.</p><h4 id="2-구현-Implementation"><a href="#2-구현-Implementation" class="headerlink" title="2. 구현(Implementation)"></a>2. 구현(Implementation)</h4><p>JVM 사양 구현은 실제 소프트웨어 프로그램을 도출하며, 이것이 JVM 구현이다. 실제로, 오픈소스와 특정 업체 고유의 JVM 구현이 다수 존재한다. 오픈JDK의 핫스팟(HotSpot) JVM은 참조 구현이며, 세계에서 가장 철저하게 증명된 코드기반 중 하나로 남아있다. 핫스팟은 가장 널리 사용되는 JVM이기도 하다.</p><p>오라클의 라이선스가 부여된 JDK를 포함해, 라이선스가 부여되는 거의 모든 JVM은 오픈JDK와 핫스팟 JVM의 포크(Fork)로 생성된 것이다. 오픈JDK로부터 허가받은 포크를 생성하는 개발자들은 종종 운영체제 고유의 성능 개선사항들을 추가하려는 욕구에 의해 동기 부여된다. 일반적으로, 개발자는 JRE(Java Runtime Environment) 번들의 한 부분으로 JVM을 다운로드해 설치한다.</p><h4 id="3-인스턴스-Instance"><a href="#3-인스턴스-Instance" class="headerlink" title="3. 인스턴스(Instance)"></a>3. 인스턴스(Instance)</h4><p>JVM 스펙이 구현돼서 소프트웨어 제품으로 릴리즈되면, 개발자는 그것을 하나의 프로그램처럼 다운로드해 실행할 수 있다. 이렇게 다운로드 된 프로그램이 하나의 JVM 인스턴스(또는 인스턴스화된 버전)이다.</p><p>개발자들이 “JVM”에 대해 말하는 경우, 대부분의 경우에는 소프트웨어 개발 환경 또는 제품화 환경에서 실행되는 하나의 JVM 인스턴스를 지칭한다. “아난드, 그 서버에 있는 JVM은 메모리를 얼마나 사용하고 있어?” 또는 “순환 호출(Circular Call)을 하는 바람에 스택 오버플로우 에러가 내 JVM을 망가뜨렸다니, 믿을 수가 없군. 이런 초보적인 실수를 하다니!”라고 말할 지도 모른다.</p><hr><h3 id="JDK와-JRE의-차이"><a href="#JDK와-JRE의-차이" class="headerlink" title="JDK와 JRE의 차이"></a>JDK와 JRE의 차이</h3><p>간단하게 설명하면 다음과 같다.</p><p><strong>JRE란?</strong><br>먼저 JRE는 Java Runtime Environment의 약자로 자바 프로그램을 실행시켜주는 환경을 구성해주는 도구다. 즉 JAVA를 개발할 필요는 없는데, 실행은 시켜줘야 하는 경우에는 꼭 JRE가 있어야 한다. 반면 JAVA 개발시 꼭 필요한 것이 있는데 그것이 바로 JDK다.</p><p><strong>JDK란?</strong><br>JDK는 Java Development Kit의 약자로 말그대로 자바 개발시 필요한 툴킷을 제공하는 도구모음이다. 개발하려면 당연히 실행도 시켜야 하므로 JDK 안에는 JRE가 포함되어 있다. </p><p>사용자 입장에서 요약하자면<br>JAVA로 만들어진 프로그램을 실행만 시킬 것이라면  JRE만 설치하면 되고<br>JAVA 개발자라면 JDK를 설치하면 된다.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] 멀쩡한사각형</title>
      <link href="2021/01/10/algorithm_210119/"/>
      <url>2021/01/10/algorithm_210119/</url>
      
        <content type="html"><![CDATA[<h1 id="멀쩡한-사각형-Summer-Winter-Coding-2019"><a href="#멀쩡한-사각형-Summer-Winter-Coding-2019" class="headerlink" title="멀쩡한 사각형 (Summer/Winter Coding(2019))"></a>멀쩡한 사각형 (Summer/Winter Coding(2019))</h1><hr><h2 id="문제설명"><a href="#문제설명" class="headerlink" title="문제설명"></a>문제설명</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다.</span><br><span class="line"> 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.</span><br><span class="line">가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.</span><br></pre></td></tr></table></figure><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W, H : 1억 이하의 자연수</span><br></pre></td></tr></table></figure><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><table><thead><tr><th>W</th><th align="center">H</th><th align="right">result</th></tr></thead><tbody><tr><td>8</td><td align="center">12</td><td align="right">80</td></tr></tbody></table><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">입출력 예 #1</span><br><span class="line">가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 &#x3D; 80 을 반환합니다.</span><br></pre></td></tr></table></figure><p><img src="https://grepp-programmers.s3.amazonaws.com/files/production/ee895b2cd9/567420db-20f4-4064-afc3-af54c4a46016.png" alt="example"></p><hr><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><p>처음에 문제를 봤을 때 바로 떠오른 생각이 최대공약수 개념이었다.<br>위에 있는 그림은 스크롤을 내리지 못해 미처 발견하지 못했고 혼자서 생각해보았다.</p><p>5분 정도 혼자 고민을 한 끝에 최대공약수로는 판단할 수 없다고 생각을 했다.</p><p>따라서, 구글링을 통해 [대각선이 지나는 점의 개수]를 찾는 방법을 찾았다.<br>[대각선이 지나는 점의 개수] : <a href="https://m.blog.naver.com/orbis1020/220664563768">https://m.blog.naver.com/orbis1020/220664563768</a><br><br><br><img src="https://mblogthumb-phinf.pstatic.net/20160324_159/orbis1020_1458747302465IxfMV_PNG/%B0%DD%C0%DA.png?type=w2" alt="example"></p><p>초등학교 5학년의 수학문제라는 점에서 자괴감이 들었다. 나는. 4학년이니까 괜찮다! (..대학교)</p><p>본론으로 다시 넘어와서 점의 개수는 위의 그림처럼 격자점의 유무에 따라 달라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) 격자점이 존재할 경우 : 가로와 세로의 최대공약수가 2일 때</span><br><span class="line">(2) 격자점이 존재하지 않을 경우 : 두 수의 최대공약수가 1일 때</span><br><span class="line"></span><br><span class="line">(1)의 경우에는 &#39;(가로)+(세로)-1&#39;</span><br><span class="line">(2)의 경우에는 &#39;(가로)+(세로)-(가로와 세로의 최대공약수)</span><br></pre></td></tr></table></figure><p>하지만 둘 다 코드에선 같은 최대공약수를 빼므로 결론적으론 (가로) + (세로) - (최대공약수)임을 알 수 있다.</p><p>최대 공약수를 구하는 방법은 다양한 방법이 있겠지만 Level1에서 배웠던 유클리드호제법을 사용하여 구했다. (Level1_C++_gcdlcm)</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long gcd(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    long c;</span><br><span class="line"></span><br><span class="line">    while (b !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        c &#x3D; a % b;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">long long solution(int w, int h) &#123;</span><br><span class="line">    long long W &#x3D; w;</span><br><span class="line">    long long H &#x3D; h;</span><br><span class="line"></span><br><span class="line">    return (W * H) - ((W + H) - gcd(W, H));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Programmers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
